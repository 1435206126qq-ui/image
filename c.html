<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡åˆæˆç¼–è¾‘å™¨</title>
    <style>
        :root {
            --primary: #4b6cb7;
            --bg: #f5f7fa;
            --sidebar-w: 260px;
            --thumbnail-w: 180px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        
        body {
            background: var(--bg);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        /* ===== ç¬¬ä¸€æ ï¼šæ§åˆ¶é¢æ¿ ===== */
        .control-sidebar {
            width: var(--sidebar-w);
            background: white;
            border-right: 1px solid #ddd;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
        }

        .control-group {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }
        .label { font-size: 14px; font-weight: bold; color: #333; margin-bottom: 8px; display: block; }
        
        .btn {
            width: 100%; padding: 10px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: bold; transition: 0.2s; margin-bottom: 5px;
        }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { opacity: 0.9; }
        .btn-danger { background: #dc3545; color: white; }
        
        /* æ»‘å—æ ·å¼ */
        .slider-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .slider-label { width: 40px; color: #666; }
        .slider-val { width: 40px; text-align: right; color: var(--primary); font-weight: bold; }
        input[type="range"] { flex: 1; cursor: pointer; margin: 0 5px; }

        /* æ¨¡å¼åˆ‡æ¢ */
        .mode-switch { display: flex; background: #eee; border-radius: 4px; padding: 2px; }
        .mode-switch button {
            flex: 1; border: none; background: none; padding: 6px;
            font-size: 12px; cursor: pointer; border-radius: 4px;
        }
        .mode-switch button.active { background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); color: var(--primary); font-weight: bold;}

        /* ===== ç¬¬äºŒæ ï¼šç¼©ç•¥å›¾åˆ—è¡¨ ===== */
        .thumbnail-sidebar {
            width: var(--thumbnail-w);
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
        }
        
        .thumbnail-header {
            padding: 15px;
            background: white;
            border-bottom: 1px solid #ddd;
            text-align: center;
        }
        
        .thumbnail-header h4 {
            font-size: 14px;
            color: #333;
            margin: 0;
        }
        
        .thumbnail-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        /* ç¼©ç•¥å›¾é¡¹ */
        .thumbnail-item {
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
        }
        
        .thumbnail-item.selected {
            border-color: var(--primary);
            background: #eef4ff;
            box-shadow: 0 0 0 2px rgba(75, 108, 183, 0.3);
        }
        
        .thumbnail-item.dragging {
            opacity: 0.7;
            transform: scale(0.98);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .thumbnail-img {
            width: 100%;
            height: 100px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }
        
        .thumbnail-img img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .thumbnail-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
        }
        
        .thumbnail-name {
            color: #333;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        
        .thumbnail-index {
            background: var(--primary);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            margin-right: 5px;
            flex-shrink: 0;
        }
        
        .thumbnail-item.selected .thumbnail-index {
            background: #ff9900;
        }
        
        .thumbnail-del {
            color: #999;
            cursor: pointer;
            font-size: 16px;
            padding: 0 5px;
            flex-shrink: 0;
        }
        
        .thumbnail-del:hover {
            color: red;
        }
        
        /* æ‹–æ‹½æç¤º */
        .drag-hint {
            height: 4px;
            background: var(--primary);
            border-radius: 2px;
            margin: 2px 0;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .drag-hint.active {
            opacity: 1;
        }
        
        /* ç©ºçŠ¶æ€ */
        .empty-thumbnails {
            text-align: center;
            color: #999;
            padding: 40px 20px;
            font-size: 13px;
        }
        
        /* ===== ç¬¬ä¸‰æ ï¼šé¢„è§ˆåŒºåŸŸ ===== */
        .preview-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f0f2f5;
            overflow: hidden;
        }
        
        .preview-header {
            padding: 15px 20px;
            background: white;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .preview-header h4 {
            font-size: 16px;
            color: #333;
            margin: 0;
        }
        
        .preview-tools {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .preview-content {
            flex: 1;
            overflow: hidden; /* æ”¹ä¸ºhiddenï¼Œå†…éƒ¨æ»šåŠ¨ */
            position: relative; /* ä¸ºcanvaså®šä½åšå‡†å¤‡ */
        }
        
        /* é¢„è§ˆç”»å¸ƒå®¹å™¨ */
        .preview-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: white;
        }
        
        /* å…³é”®ï¼šcanvasåŒ…è£…å™¨ç”¨äºç¼©æ”¾å’Œæ‹–æ‹½ */
        .canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab; /* é»˜è®¤æ‰‹å½¢å…‰æ ‡ */
            user-select: none;
            touch-action: none; /* é˜²æ­¢è§¦æ‘¸é»˜è®¤è¡Œä¸º */
        }
        
        .canvas-wrapper.dragging {
            cursor: grabbing; /* æ‹–æ‹½æ—¶çš„æ‰‹å½¢ */
        }
        
        canvas {
            display: block;
            position: absolute;
            transform-origin: 0 0; /* ç¼©æ”¾åŸç‚¹ */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            max-width: none; /* ç§»é™¤æœ€å¤§å®½åº¦é™åˆ¶ */
        }
        
        /* ç¼©æ”¾æ§åˆ¶ */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        .zoom-btn {
            width: 30px;
            height: 30px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .zoom-btn:hover {
            background: #e9ecef;
        }
        
        .zoom-level {
            font-size: 12px;
            color: #333;
            min-width: 60px;
            text-align: center;
        }
        
        /* æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ */
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            margin-top: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            border-color: var(--primary);
            background: #f8f9fa;
        }
        
        .upload-icon {
            font-size: 40px;
            color: #6c757d;
            margin-bottom: 10px;
        }
        
        .upload-text {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .upload-hint {
            font-size: 12px;
            color: #999;
        }
        
        /* ç¼©æ”¾æç¤º */
        .zoom-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .zoom-hint.show {
            opacity: 1;
        }

    </style>
</head>
<body>

    <!-- ç¬¬ä¸€æ ï¼šæ§åˆ¶é¢æ¿ -->
    <div class="control-sidebar">
        <h2 style="font-size: 18px; color: #333; margin-bottom: 10px;">å›¾ç‰‡åˆæˆè®¾ç½®</h2>
        
        <input type="file" id="fileInput" multiple accept="image/*" style="display:none">
        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <div class="upload-icon">ğŸ“</div>
            <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½æ·»åŠ å›¾ç‰‡</div>
            <div class="upload-hint">æ”¯æŒ JPGã€PNG æ ¼å¼</div>
        </div>
        
        <div class="control-group">
            <span class="label">è£å‰ªæ¨¡å¼</span>
            <div class="mode-switch">
                <button class="active" data-mode="single" onclick="setMode('single')">é€‰ä¸­å¾®è°ƒ</button>
                <button data-mode="global" onclick="setMode('global')">å…¨å±€ç»Ÿä¸€</button>
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: #666; min-height: 16px;" id="selectedInfo">
                è¯·æ·»åŠ å¹¶é€‰ä¸­å›¾ç‰‡
            </div>
        </div>

        <div class="control-group">
            <span class="label">è£å‰ªè®¾ç½® (0-300px)</span>
            
            <div class="slider-row">
                <span class="slider-label">ä¸Š</span>
                <input type="range" min="0" max="300" value="0" id="cropTop" oninput="handleCropInput('top', this.value)">
                <span class="slider-val" id="valTop">0</span>
            </div>
            <div class="slider-row">
                <span class="slider-label">ä¸‹</span>
                <input type="range" min="0" max="300" value="0" id="cropBottom" oninput="handleCropInput('bottom', this.value)">
                <span class="slider-val" id="valBottom">0</span>
            </div>
            <div class="slider-row">
                <span class="slider-label">å·¦</span>
                <input type="range" min="0" max="300" value="0" id="cropLeft" oninput="handleCropInput('left', this.value)">
                <span class="slider-val" id="valLeft">0</span>
            </div>
            <div class="slider-row">
                <span class="slider-label">å³</span>
                <input type="range" min="0" max="300" value="0" id="cropRight" oninput="handleCropInput('right', this.value)">
                <span class="slider-val" id="valRight">0</span>
            </div>
        </div>

        <div class="control-group">
            <span class="label">é—´è·è®¾ç½®</span>
            <input type="range" style="width:100%" min="0" max="100" value="0" id="spacingSlider" oninput="updateSpacing(this.value)">
            <div style="display:flex; justify-content:space-between; margin-top:5px;">
                <span style="font-size:12px" id="spacingVal">0px</span>
                <input type="color" value="#ffffff" style="height:20px; width:40px; border:none;" id="spacingColor" oninput="renderPreview()">
            </div>
        </div>

        <button class="btn btn-danger" onclick="clearAll()">æ¸…ç©ºæ‰€æœ‰å›¾ç‰‡</button>
        
        <div style="margin-top: auto; padding-top:10px; border-top:1px solid #eee;">
            <button class="btn btn-primary" onclick="downloadImage()">ä¸‹è½½åˆæˆå›¾ç‰‡</button>
        </div>
    </div>

    <!-- ç¬¬äºŒæ ï¼šç¼©ç•¥å›¾åˆ—è¡¨ -->
    <div class="thumbnail-sidebar">
        <div class="thumbnail-header">
            <h4>å›¾ç‰‡åˆ—è¡¨ (<span id="imgCount">0</span>)</h4>
        </div>
        
        <div class="thumbnail-list" id="thumbnailList">
            <div class="empty-thumbnails">è¯·ä»å·¦ä¾§æ·»åŠ å›¾ç‰‡</div>
        </div>
    </div>

    <!-- ç¬¬ä¸‰æ ï¼šé¢„è§ˆåŒºåŸŸ -->
    <div class="preview-area">
        <div class="preview-header">
            <h4>é¢„è§ˆåŒºåŸŸ (æ»šè½®ç¼©æ”¾ï¼Œå·¦é”®æ‹–æ‹½)</h4>
            <div class="preview-tools">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="changeZoom(-0.1)">-</button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="zoom-btn" onclick="changeZoom(0.1)">+</button>
                    <button class="zoom-btn" onclick="resetView()" style="font-size:12px;">é‡ç½®</button>
                </div>
            </div>
        </div>
        
        <div class="preview-content" id="previewContent">
            <div class="preview-container">
                <!-- CanvasåŒ…è£…å™¨ï¼Œç”¨äºå¤„ç†äº¤äº’ -->
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- ç¼©æ”¾æç¤º -->
    <div class="zoom-hint" id="zoomHint">æ»šè½®ç¼©æ”¾ï¼Œå·¦é”®æ‹–æ‹½</div>

    <script>
        // ========== å…¨å±€å˜é‡ ==========
        let images = []; 
        let globalCrop = { top: 0, bottom: 0, left: 0, right: 0 };
        let currentMode = 'single'; 
        let selectedIndex = -1;
        let spacing = 0;
        
        // æ–°å¢ï¼šç¼©æ”¾å’Œæ‹–æ‹½ç›¸å…³å˜é‡
        let zoomLevel = 1.0;
        let viewportOffset = { x: 0, y: 0 };
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };
        let canvasSize = { width: 0, height: 0 }; // canvasåŸå§‹å°ºå¯¸
        let transformMatrix = { x: 0, y: 0, scale: 1 }; // å½“å‰å˜æ¢
        
        // DOMå…ƒç´ 
        const fileInput = document.getElementById('fileInput');
        const thumbnailList = document.getElementById('thumbnailList');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewContent = document.getElementById('previewContent');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const zoomHint = document.getElementById('zoomHint');

        // ========== æ–‡ä»¶ä¸Šä¼ å¤„ç† ==========
        fileInput.addEventListener('change', async (e) => {
            if (e.target.files.length === 0) return;
            
            const newFiles = Array.from(e.target.files);
            const loadPromises = newFiles.map(file => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = URL.createObjectURL(file);
                    img.onload = () => {
                        resolve({
                            imgObj: img,
                            name: file.name,
                            id: Date.now() + Math.random(),
                            crop: { top: 0, bottom: 0, left: 0, right: 0 }
                        });
                    };
                });
            });
            
            const newImages = await Promise.all(loadPromises);
            images = [...images, ...newImages];
            
            // é»˜è®¤é€‰ä¸­ç¬¬ä¸€å¼ 
            if (images.length > 0 && selectedIndex === -1) {
                selectImage(0);
            }
            
            renderThumbnails();
            renderPreview();
            
            fileInput.value = '';
        });
        
        // æ‹–æ‹½ä¸Šä¼ æ”¯æŒ
        const uploadArea = document.querySelector('.upload-area');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--primary)';
            uploadArea.style.background = '#f0f7ff';
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.borderColor = '#ddd';
            uploadArea.style.background = '';
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#ddd';
            uploadArea.style.background = '';
            
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                fileInput.dispatchEvent(new Event('change'));
            }
        });

        // ========== ç¼©ç•¥å›¾åˆ—è¡¨æ¸²æŸ“ ==========
        function renderThumbnails() {
            const imgCount = images.length;
            document.getElementById('imgCount').textContent = imgCount;
            
            if (imgCount === 0) {
                thumbnailList.innerHTML = '<div class="empty-thumbnails">è¯·ä»å·¦ä¾§æ·»åŠ å›¾ç‰‡</div>';
                return;
            }
            
            thumbnailList.innerHTML = '';
            
            images.forEach((item, index) => {
                // åˆ›å»ºæ‹–æ‹½æç¤ºçº¿
                if (index > 0) {
                    const hint = document.createElement('div');
                    hint.className = 'drag-hint';
                    hint.dataset.position = index;
                    thumbnailList.appendChild(hint);
                }
                
                // åˆ›å»ºç¼©ç•¥å›¾é¡¹
                const itemEl = document.createElement('div');
                itemEl.className = `thumbnail-item ${index === selectedIndex ? 'selected' : ''}`;
                itemEl.draggable = true;
                itemEl.dataset.index = index;
                
                // æ‹–æ‹½äº‹ä»¶
                itemEl.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    itemEl.classList.add('dragging');
                    
                    // æ˜¾ç¤ºæ‰€æœ‰æç¤ºçº¿
                    document.querySelectorAll('.drag-hint').forEach(hint => {
                        hint.classList.add('active');
                    });
                });
                
                itemEl.addEventListener('dragend', () => {
                    itemEl.classList.remove('dragging');
                    // éšè—æ‰€æœ‰æç¤ºçº¿
                    document.querySelectorAll('.drag-hint').forEach(hint => {
                        hint.classList.remove('active');
                    });
                });
                
                itemEl.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });
                
                itemEl.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = index;
                    
                    if (fromIndex !== toIndex) {
                        moveImage(fromIndex, toIndex);
                    }
                });
                
                // ç‚¹å‡»é€‰ä¸­
                itemEl.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('thumbnail-del')) {
                        selectImage(index);
                    }
                });
                
                // è®¡ç®—è£å‰ªåçš„ç¼©ç•¥å›¾
                const c = item.crop;
                const t = c.top + globalCrop.top;
                const b = c.bottom + globalCrop.bottom;
                const l = c.left + globalCrop.left;
                const r = c.right + globalCrop.right;
                
                const sw = Math.max(1, item.imgObj.width - l - r);
                const sh = Math.max(1, item.imgObj.height - t - b);
                
                // åˆ›å»ºä¸´æ—¶canvasç»˜åˆ¶è£å‰ªåçš„ç¼©ç•¥å›¾
                const thumbCanvas = document.createElement('canvas');
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCanvas.width = 140;
                thumbCanvas.height = 90;
                
                // è®¡ç®—ç¼©ç•¥å›¾ç»˜åˆ¶å‚æ•°
                const scale = Math.min(thumbCanvas.width / sw, thumbCanvas.height / sh) * 0.8;
                const drawWidth = sw * scale;
                const drawHeight = sh * scale;
                const offsetX = (thumbCanvas.width - drawWidth) / 2;
                const offsetY = (thumbCanvas.height - drawHeight) / 2;
                
                // ç»˜åˆ¶è£å‰ªåçš„å›¾ç‰‡
                thumbCtx.fillStyle = '#f5f5f5';
                thumbCtx.fillRect(0, 0, thumbCanvas.width, thumbCanvas.height);
                thumbCtx.drawImage(
                    item.imgObj,
                    l, t, sw, sh,
                    offsetX, offsetY, drawWidth, drawHeight
                );
                
                // æ·»åŠ è£å‰ªè¾¹æ¡†æç¤º
                if (t > 0 || b > 0 || l > 0 || r > 0) {
                    thumbCtx.strokeStyle = 'rgba(255, 153, 0, 0.6)';
                    thumbCtx.lineWidth = 2;
                    thumbCtx.strokeRect(offsetX, offsetY, drawWidth, drawHeight);
                }
                
                const thumbDataUrl = thumbCanvas.toDataURL();
                
                itemEl.innerHTML = `
                    <div class="thumbnail-img">
                        <img src="${thumbDataUrl}" alt="${item.name}">
                    </div>
                    <div class="thumbnail-info">
                        <div class="thumbnail-index">${index + 1}</div>
                        <div class="thumbnail-name">${item.name.length > 15 ? item.name.substring(0, 12) + '...' : item.name}</div>
                        <div class="thumbnail-del" onclick="removeImage(${index})">&times;</div>
                    </div>
                `;
                
                thumbnailList.appendChild(itemEl);
            });
        }

        // ========== å›¾ç‰‡é€‰æ‹© ==========
        function selectImage(index) {
            if (index < 0 || index >= images.length) return;
            
            selectedIndex = index;
            renderThumbnails();
            
            if (currentMode === 'single') {
                updateInputs(images[index].crop);
                document.getElementById('selectedInfo').textContent = `å½“å‰è°ƒæ•´: ${images[index].name}`;
            }
            
            // ç¡®ä¿é€‰ä¸­çš„ç¼©ç•¥å›¾åœ¨å¯è§†åŒºåŸŸå†…
            const selectedItem = thumbnailList.querySelector(`.thumbnail-item[data-index="${index}"]`);
            if (selectedItem) {
                selectedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // ========== æ¨¡å¼è®¾ç½® ==========
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-switch button').forEach(b => {
                b.classList.toggle('active', b.dataset.mode === mode);
            });

            if (mode === 'global') {
                updateInputs(globalCrop);
                document.getElementById('selectedInfo').textContent = "æ¨¡å¼: å…¨å±€ç»Ÿä¸€è°ƒæ•´ (æ‰€æœ‰å›¾ç‰‡ç”Ÿæ•ˆ)";
                selectedIndex = -1;
                renderThumbnails();
            } else {
                if (images.length > 0) {
                    selectImage(0);
                } else {
                    document.getElementById('selectedInfo').textContent = "è¯·æ·»åŠ å¹¶é€‰ä¸­å›¾ç‰‡";
                }
            }
        }

        // ========== è¾“å…¥æ§ä»¶æ›´æ–° ==========
        function updateInputs(cropObj) {
            ['Top','Bottom','Left','Right'].forEach(side => {
                const key = side.toLowerCase();
                const val = cropObj[key];
                document.getElementById('crop'+side).value = val;
                document.getElementById('val'+side).textContent = val;
            });
        }

        function handleCropInput(side, value) {
            const val = parseInt(value) || 0;
            document.getElementById('val'+side.charAt(0).toUpperCase() + side.slice(1)).textContent = val;

            if (currentMode === 'global') {
                globalCrop[side] = val;
            } else {
                if (selectedIndex === -1) return;
                images[selectedIndex].crop[side] = val;
            }
            
            // å®æ—¶æ›´æ–°
            renderThumbnails();
            renderPreview();
        }

        function updateSpacing(val) {
            spacing = parseInt(val);
            document.getElementById('spacingVal').textContent = val + 'px';
            renderPreview();
        }

        // ========== å›¾ç‰‡ç®¡ç† ==========
        function moveImage(from, to) {
            if (from === to) return;
            
            const item = images.splice(from, 1)[0];
            images.splice(to, 0, item);
            
            if (selectedIndex === from) {
                selectedIndex = to;
            } else if (selectedIndex > from && selectedIndex <= to) {
                selectedIndex--;
            } else if (selectedIndex < from && selectedIndex >= to) {
                selectedIndex++;
            }
            
            renderThumbnails();
            renderPreview();
        }

        function removeImage(index) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤ç¬¬${index + 1}å¼ å›¾ç‰‡å—ï¼Ÿ`)) return;
            
            images.splice(index, 1);
            
            if (selectedIndex === index) {
                selectedIndex = -1;
                if (images.length > 0) {
                    selectImage(0);
                }
            } else if (selectedIndex > index) {
                selectedIndex--;
            }
            
            renderThumbnails();
            renderPreview();
        }

        function clearAll() {
            // ç›´æ¥æ¸…ç©ºï¼Œä¸éœ€è¦ç¡®è®¤
            images = [];
            globalCrop = { top: 0, bottom: 0, left: 0, right: 0 };
            selectedIndex = -1;
            updateInputs(globalCrop);
            renderThumbnails();
            renderPreview();
            document.getElementById('selectedInfo').textContent = "è¯·æ·»åŠ å¹¶é€‰ä¸­å›¾ç‰‡";
            resetView();
        }

        // ========== é¢„è§ˆæ¸²æŸ“ ==========
        function renderPreview() {
            if (images.length === 0) {
                // æ¸…ç©ºç”»å¸ƒ
                previewCanvas.width = 800;
                previewCanvas.height = 400;
                canvasSize.width = 800;
                canvasSize.height = 400;
                
                const ctx = previewCanvas.getContext('2d');
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = '#999';
                ctx.textAlign = 'center';
                ctx.fillText('è¯·æ·»åŠ å›¾ç‰‡å¼€å§‹åˆæˆ', previewCanvas.width / 2, previewCanvas.height / 2);
                
                updateCanvasDisplay();
                return;
            }
            
            // è®¡ç®—æ¯å¼ å›¾ç‰‡çš„ä½ç½®å’Œå°ºå¯¸
            let maxWidth = 0;
            const renderData = images.map((img, idx) => {
                const c = img.crop;
                const t = c.top + globalCrop.top;
                const b = c.bottom + globalCrop.bottom;
                const l = c.left + globalCrop.left;
                const r = c.right + globalCrop.right;

                const sw = Math.max(1, img.imgObj.width - l - r);
                const sh = Math.max(1, img.imgObj.height - t - b);
                
                if (sw > maxWidth) maxWidth = sw;

                return { 
                    ...img, 
                    index: idx,
                    sw: sw, 
                    sh: sh, 
                    sx: l, 
                    sy: t 
                };
            });

            let totalHeight = 0;
            renderData.forEach((d) => {
                d.renderScale = maxWidth / d.sw;
                d.renderHeight = d.sh * d.renderScale;
                totalHeight += d.renderHeight;
                
                if (d.index < renderData.length - 1) {
                    totalHeight += spacing;
                }
            });
            
            // è®¾ç½®canvasçš„åŸå§‹åƒç´ å°ºå¯¸
            canvasSize.width = maxWidth;
            canvasSize.height = totalHeight;
            previewCanvas.width = canvasSize.width;
            previewCanvas.height = canvasSize.height;
            
            const ctx = previewCanvas.getContext('2d');
            
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // ç»˜åˆ¶é—´è·èƒŒæ™¯
            if (spacing > 0) {
                ctx.fillStyle = document.getElementById('spacingColor').value;
                ctx.fillRect(0, 0, canvasSize.width, canvasSize.height);
            }

            // ç»˜åˆ¶å›¾ç‰‡
            let currentY = 0;
            renderData.forEach((d) => {
                const renderHeight = d.sh * d.renderScale;
                
                ctx.drawImage(
                    d.imgObj,
                    d.sx, d.sy, d.sw, d.sh,
                    0, currentY, canvasSize.width, renderHeight
                );
                currentY += renderHeight + spacing;
            });
            
            // æ›´æ–°æ˜¾ç¤º
            updateCanvasDisplay();
        }

        // ========== ç¼©æ”¾å’Œæ‹–æ‹½åŠŸèƒ½ ==========
        function updateCanvasDisplay() {
            // æ›´æ–°canvasçš„CSSå˜æ¢
            previewCanvas.style.transform = `translate(${transformMatrix.x}px, ${transformMatrix.y}px) scale(${transformMatrix.scale})`;
            
            // æ›´æ–°ç¼©æ”¾æ˜¾ç¤º
            document.getElementById('zoomLevel').textContent = Math.round(transformMatrix.scale * 100) + '%';
        }

        // æ»šè½®ç¼©æ”¾å‡½æ•°
        function handleWheelZoom(e) {
            e.preventDefault();
            
            const rect = canvasWrapper.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // è®¡ç®—é¼ æ ‡åœ¨canvasä¸Šçš„ç›¸å¯¹ä½ç½®
            const canvasX = (mouseX - transformMatrix.x) / transformMatrix.scale;
            const canvasY = (mouseY - transformMatrix.y) / transformMatrix.scale;
            
            // ç¼©æ”¾å› å­
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = transformMatrix.scale * zoomFactor;
            
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            const minScale = 0.1;
            const maxScale = 10;
            if (newScale < minScale || newScale > maxScale) return;
            
            // ä»¥é¼ æ ‡ä½ç½®ä¸ºä¸­å¿ƒç¼©æ”¾
            const newX = mouseX - canvasX * newScale;
            const newY = mouseY - canvasY * newScale;
            
            transformMatrix.scale = newScale;
            transformMatrix.x = newX;
            transformMatrix.y = newY;
            
            updateCanvasDisplay();
            
            // æ˜¾ç¤ºæç¤º
            showZoomHint(`ç¼©æ”¾: ${Math.round(newScale * 100)}%`);
        }

        // é¼ æ ‡æ‹–æ‹½å‡½æ•°
        function startDrag(e) {
            if (e.button !== 0) return; // åªå“åº”å·¦é”®
            
            isDragging = true;
            lastMousePos.x = e.clientX;
            lastMousePos.y = e.clientY;
            
            canvasWrapper.classList.add('dragging');
            e.preventDefault();
        }

        function handleDrag(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMousePos.x;
            const deltaY = e.clientY - lastMousePos.y;
            
            transformMatrix.x += deltaX;
            transformMatrix.y += deltaY;
            
            lastMousePos.x = e.clientX;
            lastMousePos.y = e.clientY;
            
            updateCanvasDisplay();
        }

        function stopDrag() {
            isDragging = false;
            canvasWrapper.classList.remove('dragging');
        }

        // æŒ‰é’®ç¼©æ”¾å‡½æ•°
        function changeZoom(delta) {
            const container = canvasWrapper.getBoundingClientRect();
            const centerX = container.width / 2;
            const centerY = container.height / 2;
            
            // è®¡ç®—ä¸­å¿ƒç‚¹åœ¨canvasä¸Šçš„ç›¸å¯¹ä½ç½®
            const canvasX = (centerX - transformMatrix.x) / transformMatrix.scale;
            const canvasY = (centerY - transformMatrix.y) / transformMatrix.scale;
            
            const newScale = transformMatrix.scale + delta;
            
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            const minScale = 0.1;
            const maxScale = 10;
            if (newScale < minScale || newScale > maxScale) return;
            
            // ä»¥ä¸­å¿ƒç‚¹ç¼©æ”¾
            const newX = centerX - canvasX * newScale;
            const newY = centerY - canvasY * newScale;
            
            transformMatrix.scale = newScale;
            transformMatrix.x = newX;
            transformMatrix.y = newY;
            
            updateCanvasDisplay();
        }

        // é‡ç½®è§†å›¾
        function resetView() {
            // è®¡ç®—å±…ä¸­ä½ç½®
            const container = canvasWrapper.getBoundingClientRect();
            const canvasWidth = canvasSize.width;
            const canvasHeight = canvasSize.height;
            
            // å¦‚æœcanvaså°ºå¯¸ä¸º0ï¼Œåˆ™ä¸é‡ç½®
            if (canvasWidth === 0 || canvasHeight === 0) return;
            
            // è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹ä»¥é€‚é…å®¹å™¨
            const scaleX = container.width / canvasWidth;
            const scaleY = container.height / canvasHeight;
            const newScale = Math.min(scaleX, scaleY) * 0.9; // 90%é€‚é…
            
            // å±…ä¸­ä½ç½®
            const newX = (container.width - canvasWidth * newScale) / 2;
            const newY = (container.height - canvasHeight * newScale) / 2;
            
            transformMatrix.scale = newScale;
            transformMatrix.x = newX;
            transformMatrix.y = newY;
            
            updateCanvasDisplay();
            showZoomHint("è§†å›¾å·²é‡ç½®");
        }

        // æ˜¾ç¤ºç¼©æ”¾æç¤º
        function showZoomHint(message) {
            zoomHint.textContent = message;
            zoomHint.classList.add('show');
            
            clearTimeout(zoomHint.timeout);
            zoomHint.timeout = setTimeout(() => {
                zoomHint.classList.remove('show');
            }, 1500);
        }

        // ========== äº‹ä»¶ç›‘å¬å™¨è®¾ç½® ==========
        function setupInteraction() {
            // æ»šè½®ç¼©æ”¾
            canvasWrapper.addEventListener('wheel', handleWheelZoom, { passive: false });
            
            // é¼ æ ‡æ‹–æ‹½
            canvasWrapper.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
            
            // è§¦æ‘¸å±æ”¯æŒ
            canvasWrapper.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    // å•æŒ‡è§¦æ‘¸æ¨¡æ‹Ÿé¼ æ ‡æ‹–æ‹½
                    const touch = e.touches[0];
                    startDrag({
                        button: 0,
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        preventDefault: () => e.preventDefault()
                    });
                } else if (e.touches.length === 2) {
                    // åŒæŒ‡ç¼©æ”¾æ‰‹åŠ¿
                    e.preventDefault();
                }
            }, { passive: false });
            
            canvasWrapper.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isDragging) {
                    const touch = e.touches[0];
                    handleDrag({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                }
                // åŒæŒ‡ç¼©æ”¾é€»è¾‘å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
            }, { passive: false });
            
            canvasWrapper.addEventListener('touchend', stopDrag);
            canvasWrapper.addEventListener('touchcancel', stopDrag);
        }

        // ========== ä¸‹è½½åŠŸèƒ½ ==========
        function downloadImage() {
            if (images.length === 0) {
                alert("è¯·å…ˆæ·»åŠ å›¾ç‰‡");
                return;
            }
            
            // åˆ›å»ºä¸´æ—¶canvasç”¨äºä¸‹è½½ï¼ˆåŸå§‹å°ºå¯¸ï¼Œ100%ç¼©æ”¾ï¼‰
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // é‡æ–°è®¡ç®—å°ºå¯¸ï¼ˆä¸renderPreviewé€»è¾‘ç›¸åŒï¼‰
            let maxWidth = 0;
            const renderData = images.map((img) => {
                const c = img.crop;
                const t = c.top + globalCrop.top;
                const b = c.bottom + globalCrop.bottom;
                const l = c.left + globalCrop.left;
                const r = c.right + globalCrop.right;

                const sw = Math.max(1, img.imgObj.width - l - r);
                const sh = Math.max(1, img.imgObj.height - t - b);
                
                if (sw > maxWidth) maxWidth = sw;

                return { 
                    imgObj: img.imgObj,
                    sw: sw, 
                    sh: sh, 
                    sx: l, 
                    sy: t 
                };
            });

            let totalHeight = 0;
            renderData.forEach((d) => {
                const renderScale = maxWidth / d.sw;
                const renderHeight = d.sh * renderScale;
                totalHeight += renderHeight + spacing;
            });
            
            if (renderData.length > 0) {
                totalHeight -= spacing;
            }
            
            tempCanvas.width = maxWidth;
            tempCanvas.height = totalHeight;
            
            // ç»˜åˆ¶é—´è·èƒŒæ™¯
            if (spacing > 0) {
                tempCtx.fillStyle = document.getElementById('spacingColor').value;
                tempCtx.fillRect(0, 0, maxWidth, totalHeight);
            }

            // ç»˜åˆ¶å›¾ç‰‡
            let currentY = 0;
            renderData.forEach((d) => {
                const renderScale = maxWidth / d.sw;
                const renderHeight = d.sh * renderScale;
                
                tempCtx.drawImage(
                    d.imgObj,
                    d.sx, d.sy, d.sw, d.sh,
                    0, currentY, maxWidth, renderHeight
                );
                currentY += renderHeight + spacing;
            });
            
            const link = document.createElement('a');
            const filename = `åˆæˆå›¾ç‰‡_${Date.now()}.jpg`;
            
            link.download = filename;
            link.href = tempCanvas.toDataURL('image/jpeg', 0.92);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // ========== åˆå§‹åŒ– ==========
        function init() {
            // è®¾ç½®äº¤äº’äº‹ä»¶
            setupInteraction();
            
            // åˆå§‹æ¸²æŸ“
            renderPreview();
            
            // åˆå§‹é‡ç½®è§†å›¾
            setTimeout(resetView, 100);
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
        
        // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°è°ƒæ•´è§†å›¾
        window.addEventListener('resize', () => {
            setTimeout(resetView, 100);
        });

    </script>
</body>
</html>
